
## Generic code guidelines
Always add GDScript type hints everywhere. When doing null checks use `is_instance_valid(object)` rather than `object != null`. GDScripts should always end with an empty line. All `@onready` variables are private and need to start with an underscore. For constructs, that refer to other code, always use the type-safe variant without strings, e.g:

- `my_signal.emit()` rather than `emit_signal("my_signal")`
- `foo.some_signal.connect(_on_foo_some_signal)` rather than `foo.connect("some_signal", self, "_on_foo_some_signal")`

Omit `self` when not stricly needed.

## Accessing nodes 
When referring to nodes, always use scene unique names instead of paths. If a node has no scene unique name in a scene, but you need it in a script, then add a scene unique name. Always initialize node references in an `@onready` variable rather than littering the code with inline node references. When getting a node from the scene use the provided `Assure.exists` method to check that the node is there and of the right type (e.g. `@onready var _my_node: Node2D = Assure.exists(%MyNode as Node2D)`). This will ensure that the node exists and is of the correct type, and will throw an error if it is not. This also means that we don't need to check for null or type errors later in the code.

## Documentation
Always document your code using the GDScript documentation style. Use `@param` to document parameters, `@return` to document return values, and `@signal` to document signals. Documentation should focus on the "why" rather than the "how". Don't document the obvious, but rather explain the reasoning behind the code. Write in a simple, clear style avoid fancy language. Documentation for classes always goes in front of the `class_name` line, documentation for methods goes in front of the method definition. Example:

```gdscript
## This class provides utility functions for the project.
class_name Utilties

## Divides an integer number by another integer. 
## @param a The first integer to divide.
## @param b The second integer to divide. This must not be zero.
## @return The result of the division.
static func divide(a: int, b: int) -> int:
    assert(b != 0, "Division by zero is not allowed.")
    return a / b
```

All documentation happens in the code, don't add any extra documentation files.

## UIDs
Never mess with UIDs. They are automatically generated by Godot and should not be changed manually. Use paths to refer to resources, Godot will automatically convert this to UIDs when needed. If you need to refer to a resource in code, use the `load()` function with the path to the resource. Also never generate .uid files manually, they are automatically generated by Godot when the resource is saved. If you refer to resources from other resources always use the path not the uid. Leave out the uid attribute in the resource file, it will be automatically generated by Godot when the resource is saved.

## Writing tests
The test framework does not stop execution on failed assertions, so make sure the code after an assertion doesn't assume that the assertion was successful.

## Running tests
You can run tests using the `.\run_tests.cmd` file in the project root. This will run GDUnit4 in Godot and print the test results. Only run tests when specifically being asked about it.

To run only a single test suite, you can use the `-a` parameter to specify the test file or method. For example:

```
.\run_tests.cmd -a tests\test_large_trigger_plate\test_large_trigger_plate.gd
```

To run a specific test method, use the format `test_file.gd:test_method_name`:

```
.\run_tests.cmd -a tests\test_large_trigger_plate\test_large_trigger_plate.gd:test_trigger_reacts_to_two_bodies
```